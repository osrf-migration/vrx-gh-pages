{"links": {"self": {"href": "data/repositories/osrf/vrx/pullrequests/165/comments/114463150.json"}, "html": {"href": "#!/osrf/vrx/pull-requests/165/_/diff#comment-114463150"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 165, "links": {"self": {"href": "data/repositories/osrf/vrx/pullrequests/165.json"}, "html": {"href": "#!/osrf/vrx/pull-requests/165"}}, "title": "Issue#122 Ocean Reflections"}, "content": {"raw": "Hi @{557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5} I have been trying to get the plugin to work with the camera sensors over the weekend.\n\n**What works**  \nSo far I have gotten the camera sensors to show valid water \\(no missing texture issues like before\\), but they still do not have reflections.\n\n**High-level plan**  \nMy plan at a high level was to:  \n\u2022 rather than store 1 cam, 1 rttTex, 1 rt, instead I could store a vector of cameras, a vector of cams, vector of rttTexs, vector of rts  \n\u2022 At load, setup private variables such as background color, material, etc. currently in SetupRefl\\(\\)  \n\u2022 Continuously check for new cameras \\(usercams, cameras, and camera sensors\\) and add new ones to a vector of cameras in OnPreRender\\(\\)  \n\u2022 When a new camera is found, create its corresponding rttTex and rt and store it in the vector  \n\u2022 At preRenderTargetUpdate\\(\\) and postRenderTargetUpdate\\(\\), iterate through list of rts, see which one matches the source, then use the correct corresponding camera\n\n**Issues**\n\n1. My primary issue right now relates to the plugin structure. From how I understand it, the plugin is created on both the server and client. The part that confuses me is that certain functions only run on the client or the server. As well, only certain variables are accessible by the server or the client.\n\n    1. This means that there are two vectors of cameras, one on server and one on client. This is a problem\n    \n        1. The major problem is that sensors::SensorManger::Instance\\(\\)->GetSensors\\(\\) is always empty on the client, but is correct on the server. When I get new sensors, I try to add them to the vector, but this only works on the server. On the client, I never see the new cameras. As a result, inside of preRenderTargetUpdate\\(\\) and postRenderTargetUpdate\\(\\), the cameras.size\\(\\) == 1 always \\(just the one user cam I add, not any of the sensors\\). It seems that these functions are always run on the client side. Does what I am saying make sense? Is there a simple solution?\n        2. This can be shown by running `hg update e876de8` \\(this commit shows best fully what I am trying to do\\), then adding `gzerr << \"post - this->data->cameras.size(): \" << this->data->cameras.size() << std::endl;` in postRenderTargetUpdate, `gzerr << \"pre - this->data->cameras.size(): \" << this->data->cameras.size() << std::endl;` in preRenderTargetUpdate, and `gzerr << \"onPre - this->data->cameras.size(): \" << this->data->cameras.size() << std::endl; gzerr << \"onpre - new_cameras.size(): \" << new_cameras.size() << std::endl;`\n        \n    \n\n```\n[Err] [WavefieldVisualPlugin.cc:349] onpre - this->data->cameras.size(): 3  // there are actually 3 camera sensors, guessing this is on server\n[Err] [WavefieldVisualPlugin.cc:350] onpre - new_cameras.size(): 3  // first time being added\n[Err] [WavefieldVisualPlugin.cc:621] pre - this->data->cameras.size(): 1  // there is 1 user camera, no camera sensors\n[Err] [WavefieldVisualPlugin.cc:621] post - this->data->cameras.size(): 1\n[Err] [WavefieldVisualPlugin.cc:349] onpre - this->data->cameras.size(): 3  // on server, still 3 cameras\n[Err] [WavefieldVisualPlugin.cc:350] onpre - new_cameras.size(): 0 // no more new cams\n[Err] [WavefieldVisualPlugin.cc:621] pre - this->data->cameras.size(): 1  // still just 1\n[Err] [WavefieldVisualPlugin.cc:621] post - this->data->cameras.size(): 1\n[Err] [WavefieldVisualPlugin.cc:349] onpre - this->data->cameras.size(): 3\n[Err] [WavefieldVisualPlugin.cc:350] onpre - new_cameras.size(): 0 // no more new cams\n[Err] [WavefieldVisualPlugin.cc:621] pre - this->data->cameras.size(): 1 \n[Err] [WavefieldVisualPlugin.cc:621] post - this->data->cameras.size(): 1\n```\n\n* If you run add `gzerr << sensors::SensorManager::Instance()->GetSensors.size() << std::endl;` in OnPreRender and run `roslaunch vrx_gazebo vrx.launch verbose:=true` \\(has camera sensors\\), it shows something like this, with intermittent 0s which I believe correspond to the client. I don\u2019t fully understand how these 2 plugins \\(on server and client\\) are supposed to function and communicate and how I should structure this plugin for this problem\n\n```\n[Err] [WavefieldVisualPlugin.cc:333] 0\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 0\n[Err] [WavefieldVisualPlugin.cc:333] 4\n```\n\n\u200c\n\n1. I am getting some very strange behavior. In case I made some much simpler mistakes, starting from [a5cce7d](#!/osrf/vrx/commits/a5cce7d9b39744e050315fbd982c5af461d029c5?at=default), I tried to slowly increment towards what I am trying to do. I restructured the code to do the exact same thing and it was working.\n\n    1. The part with issues was going from storing `camera` to `cameras`, etc \\(should be quite simple\\). The goal was to just put only 1 camera into `cameras`, then replace `camera` with `cameras.at(0)` at all instances to maintain the exact same functionality, but have the pointers stored in vectors.\n    \n        1. The strangest thing is that I have [1b8b510](#!/osrf/vrx/commits/1b8b51023d43982f1639b3da217e90768af40980?at=default) \\(working\\) \u2192 [dcf83cc](#!/osrf/vrx/commits/dcf83cc184088ec811ae3c448bc62ef70dd3329e?at=default) \\(not working half the time\\) \u2192 [5f78b8d](#!/osrf/vrx/commits/5f78b8d33b9c53ccebac5453f36938e067d72e7d?at=default) \\(working\\), with very simple differences. By working I mean that the waves are moving. WIth the working commits, it works every time. Reflections and wave movement. In [dcf83cc](#!/osrf/vrx/commits/dcf83cc184088ec811ae3c448bc62ef70dd3329e?at=default) \\(not working half the time\\), upon running multiple times, sometimes the waves don\u2019t move and sometimes they do. I am literally commenting out completely unused variables. Any idea what this could be caused by? Do you have the same symptoms that I have?\n        2. I know it is very strange that uncommenting unused variables makes this change, but I have tested it dozens of times. The working commits work and the non-working commit works half the time.\n        \n    \n\nI really hope to be able to complete the reflections part of the camera sensor before the summer, and these issues are very strange. If you have some time I would really appreciate your input. Thank you!\n\n\u200c\n\n**Summary:** I hope to store multiple cameras, textures and rendertargets. Then at preRenderTargetUpdate\\(\\) and postRenderTargetUpdate\\(\\), check which stored rendertarget matches the renderTargetEvent source. From there, apply the correct stored textures to material on the ocean and use the correct stored camera for clipPlane and reflection.\n\nThe issue is that there are two VisualPlugin objects \\(server and client\\). It seems that preRenderTargetUpdate\\(\\) and postRenderTargetUpdate\\(\\) are always run on client, but the client also doesn\u2019t have access to the camera sensors stored to do the above checks \\(because of issues explained above\\). If the preRenderTargetUpdate\\(\\) and postRenderTargetUpdate\\(\\) functions do all the hard work of switching the textures appropriately, but they also do not have any information about the camera sensors, it is impossible to create the desired effect. \n\nPerhaps I am missing sometimes about how Gazebo plugins work, but so far I haven\u2019t been able to find any helpful information online or in the source code.", "markup": "markdown", "html": "<p>Hi <span class=\"ap-mention\" data-atlassian-id=\"557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5\">@Ian Chen</span> I have been trying to get the plugin to work with the camera sensors over the weekend.</p>\n<p><strong>What works</strong><br />\nSo far I have gotten the camera sensors to show valid water (no missing texture issues like before), but they still do not have reflections.</p>\n<p><strong>High-level plan</strong><br />\nMy plan at a high level was to:<br />\n\u2022 rather than store 1 cam, 1 rttTex, 1 rt, instead I could store a vector of cameras, a vector of cams, vector of rttTexs, vector of rts<br />\n\u2022 At load, setup private variables such as background color, material, etc. currently in SetupRefl()<br />\n\u2022 Continuously check for new cameras (usercams, cameras, and camera sensors) and add new ones to a vector of cameras in OnPreRender()<br />\n\u2022 When a new camera is found, create its corresponding rttTex and rt and store it in the vector<br />\n\u2022 At preRenderTargetUpdate() and postRenderTargetUpdate(), iterate through list of rts, see which one matches the source, then use the correct corresponding camera</p>\n<p><strong>Issues</strong></p>\n<ol>\n<li>\n<p>My primary issue right now relates to the plugin structure. From how I understand it, the plugin is created on both the server and client. The part that confuses me is that certain functions only run on the client or the server. As well, only certain variables are accessible by the server or the client.</p>\n<ol>\n<li>\n<p>This means that there are two vectors of cameras, one on server and one on client. This is a problem</p>\n<ol>\n<li>The major problem is that sensors::SensorManger::Instance()-&gt;GetSensors() is always empty on the client, but is correct on the server. When I get new sensors, I try to add them to the vector, but this only works on the server. On the client, I never see the new cameras. As a result, inside of preRenderTargetUpdate() and postRenderTargetUpdate(), the cameras.size() == 1 always (just the one user cam I add, not any of the sensors). It seems that these functions are always run on the client side. Does what I am saying make sense? Is there a simple solution?</li>\n<li>This can be shown by running <code>hg update e876de8</code> (this commit shows best fully what I am trying to do), then adding <code>gzerr &lt;&lt; \"post - this-&gt;data-&gt;cameras.size(): \" &lt;&lt; this-&gt;data-&gt;cameras.size() &lt;&lt; std::endl;</code> in postRenderTargetUpdate, <code>gzerr &lt;&lt; \"pre - this-&gt;data-&gt;cameras.size(): \" &lt;&lt; this-&gt;data-&gt;cameras.size() &lt;&lt; std::endl;</code> in preRenderTargetUpdate, and <code>gzerr &lt;&lt; \"onPre - this-&gt;data-&gt;cameras.size(): \" &lt;&lt; this-&gt;data-&gt;cameras.size() &lt;&lt; std::endl; gzerr &lt;&lt; \"onpre - new_cameras.size(): \" &lt;&lt; new_cameras.size() &lt;&lt; std::endl;</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span>[Err] [WavefieldVisualPlugin.cc:349] onpre - this-&gt;data-&gt;cameras.size(): 3  // there are actually 3 camera sensors, guessing this is on server\n[Err] [WavefieldVisualPlugin.cc:350] onpre - new_cameras.size(): 3  // first time being added\n[Err] [WavefieldVisualPlugin.cc:621] pre - this-&gt;data-&gt;cameras.size(): 1  // there is 1 user camera, no camera sensors\n[Err] [WavefieldVisualPlugin.cc:621] post - this-&gt;data-&gt;cameras.size(): 1\n[Err] [WavefieldVisualPlugin.cc:349] onpre - this-&gt;data-&gt;cameras.size(): 3  // on server, still 3 cameras\n[Err] [WavefieldVisualPlugin.cc:350] onpre - new_cameras.size(): 0 // no more new cams\n[Err] [WavefieldVisualPlugin.cc:621] pre - this-&gt;data-&gt;cameras.size(): 1  // still just 1\n[Err] [WavefieldVisualPlugin.cc:621] post - this-&gt;data-&gt;cameras.size(): 1\n[Err] [WavefieldVisualPlugin.cc:349] onpre - this-&gt;data-&gt;cameras.size(): 3\n[Err] [WavefieldVisualPlugin.cc:350] onpre - new_cameras.size(): 0 // no more new cams\n[Err] [WavefieldVisualPlugin.cc:621] pre - this-&gt;data-&gt;cameras.size(): 1 \n[Err] [WavefieldVisualPlugin.cc:621] post - this-&gt;data-&gt;cameras.size(): 1\n</pre></div>\n\n\n<ul>\n<li>If you run add <code>gzerr &lt;&lt; sensors::SensorManager::Instance()-&gt;GetSensors.size() &lt;&lt; std::endl;</code> in OnPreRender and run <code>roslaunch vrx_gazebo vrx.launch verbose:=true</code> (has camera sensors), it shows something like this, with intermittent 0s which I believe correspond to the client. I don\u2019t fully understand how these 2 plugins (on server and client) are supposed to function and communicate and how I should structure this plugin for this problem</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span>[Err] [WavefieldVisualPlugin.cc:333] 0\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 4\n[Err] [WavefieldVisualPlugin.cc:333] 0\n[Err] [WavefieldVisualPlugin.cc:333] 4\n</pre></div>\n\n\n<p>\u200c</p>\n<ol>\n<li>\n<p>I am getting some very strange behavior. In case I made some much simpler mistakes, starting from <a data-is-external-link=\"true\" href=\"#!/osrf/vrx/commits/a5cce7d9b39744e050315fbd982c5af461d029c5?at=default\" rel=\"nofollow\">a5cce7d</a>, I tried to slowly increment towards what I am trying to do. I restructured the code to do the exact same thing and it was working.</p>\n<ol>\n<li>\n<p>The part with issues was going from storing <code>camera</code> to <code>cameras</code>, etc (should be quite simple). The goal was to just put only 1 camera into <code>cameras</code>, then replace <code>camera</code> with <code>cameras.at(0)</code> at all instances to maintain the exact same functionality, but have the pointers stored in vectors.</p>\n<ol>\n<li>The strangest thing is that I have <a data-is-external-link=\"true\" href=\"#!/osrf/vrx/commits/1b8b51023d43982f1639b3da217e90768af40980?at=default\" rel=\"nofollow\">1b8b510</a> (working) \u2192 <a data-is-external-link=\"true\" href=\"#!/osrf/vrx/commits/dcf83cc184088ec811ae3c448bc62ef70dd3329e?at=default\" rel=\"nofollow\">dcf83cc</a> (not working half the time) \u2192 <a data-is-external-link=\"true\" href=\"#!/osrf/vrx/commits/5f78b8d33b9c53ccebac5453f36938e067d72e7d?at=default\" rel=\"nofollow\">5f78b8d</a> (working), with very simple differences. By working I mean that the waves are moving. WIth the working commits, it works every time. Reflections and wave movement. In <a data-is-external-link=\"true\" href=\"#!/osrf/vrx/commits/dcf83cc184088ec811ae3c448bc62ef70dd3329e?at=default\" rel=\"nofollow\">dcf83cc</a> (not working half the time), upon running multiple times, sometimes the waves don\u2019t move and sometimes they do. I am literally commenting out completely unused variables. Any idea what this could be caused by? Do you have the same symptoms that I have?</li>\n<li>I know it is very strange that uncommenting unused variables makes this change, but I have tested it dozens of times. The working commits work and the non-working commit works half the time.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>I really hope to be able to complete the reflections part of the camera sensor before the summer, and these issues are very strange. If you have some time I would really appreciate your input. Thank you!</p>\n<p>\u200c</p>\n<p><strong>Summary:</strong> I hope to store multiple cameras, textures and rendertargets. Then at preRenderTargetUpdate() and postRenderTargetUpdate(), check which stored rendertarget matches the renderTargetEvent source. From there, apply the correct stored textures to material on the ocean and use the correct stored camera for clipPlane and reflection.</p>\n<p>The issue is that there are two VisualPlugin objects (server and client). It seems that preRenderTargetUpdate() and postRenderTargetUpdate() are always run on client, but the client also doesn\u2019t have access to the camera sensors stored to do the above checks (because of issues explained above). If the preRenderTargetUpdate() and postRenderTargetUpdate() functions do all the hard work of switching the textures appropriately, but they also do not have any information about the camera sensors, it is impossible to create the desired effect. </p>\n<p>Perhaps I am missing sometimes about how Gazebo plugins work, but so far I haven\u2019t been able to find any helpful information online or in the source code.</p>", "type": "rendered"}, "created_on": "2019-08-26T17:54:20.657165+00:00", "user": {"display_name": "Tyler Lum", "uuid": "{305d9368-23ba-4f72-b1d4-7d17d2a062d8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B305d9368-23ba-4f72-b1d4-7d17d2a062d8%7D"}, "html": {"href": "https://bitbucket.org/%7B305d9368-23ba-4f72-b1d4-7d17d2a062d8%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/5b96b66385af94340e7cabce/b8bb780f-62b7-47f8-9d03-ee65c7d17ad4/128"}}, "nickname": "tylerlum", "type": "user", "account_id": "5b96b66385af94340e7cabce"}, "updated_on": "2019-08-26T18:24:12.267590+00:00", "type": "pullrequest_comment", "id": 114463150}