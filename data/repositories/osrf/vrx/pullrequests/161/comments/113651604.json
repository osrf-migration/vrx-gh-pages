{"links": {"self": {"href": "data/repositories/osrf/vrx/pullrequests/161/comments/113651604.json"}, "html": {"href": "#!/osrf/vrx/pull-requests/161/_/diff#comment-113651604"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 161, "links": {"self": {"href": "data/repositories/osrf/vrx/pullrequests/161.json"}, "html": {"href": "#!/osrf/vrx/pull-requests/161"}}, "title": "Learn Gazebo Visual Plugins for Ocean Reflections"}, "content": {"raw": "In 1547:2f9414884e09, I have a very simple vertex and fragment shader. However, it is still not working.\n\n![](data/bitbucket.org/repo/BgXLzgM/images/1211094543-image.png)\nThis is what the plane looks like \\(does not have projectiveTexturing turned on, so it simply puts the image of the user camera onto the surface\\) The big black blob is actually the WAM-V in the texture. ProjectiveTexturing had to be turned off because it would not allow shader use, as per Ogre Manual:\n\n```\nvoid Ogre::TextureUnitState::setProjectiveTexturing    (    bool     enabled,\nconst Frustum *     projectionSettings = 0 \n)        \nEnables or disables projective texturing on this texture unit.\n\nRemarks\nProjective texturing allows you to generate texture coordinates based on a Frustum, which gives the impression that a texture is being projected onto the surface. Note that once you have called this method, the texture unit continues to monitor the Frustum you passed in and the projection will change if you can alter it. It also means that you must ensure that the Frustum object you pass a pointer to remains in existence for as long as this TextureUnitState does.\nThis effect cannot be combined with other texture generation effects, such as environment mapping. It also has no effect on passes which have a vertex program enabled - projective texturing has to be done in the vertex program instead.\n```\n\n**C\\+\\+ Code** I am simply creating a new texture called `mytexture`, setting it up with the user camera for render-to-texture, then adding this texture to the texture unit in the `reflection` material.\n\n```\n    Ogre::TexturePtr rttTexture =\n      Ogre::TextureManager::getSingleton().createManual(\n        \"mytexture\",\n        Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,\n        Ogre::TEX_TYPE_2D,\n        512, 512,\n        0,\n        Ogre::PF_R8G8B8,\n        Ogre::TU_RENDERTARGET);\n    this->data->renderTarget = rttTexture->getBuffer()->getRenderTarget();\n\n    // Setup camera\n    this->data->camera = this->data->scene->GetUserCamera(0)->OgreCamera();\n\n    // Setup render texture\n    this->data->renderTarget->addViewport(this->data->camera);\n    this->data->renderTarget->getViewport(0)->setClearEveryFrame(true);\n    (this->data->renderTarget->getViewport(0)->\n     setBackgroundColour(Ogre::ColourValue::Black));\n\n    Ogre::MaterialPtr renderMaterial = Ogre::MaterialManager::getSingleton().getByName(\"reflection\");\n    Ogre::TextureUnitState* t = (renderMaterial->getTechnique(0)->getPass(0)->getTextureUnitState(0));\n    t->setTexture(rttTexture);\n\n    t->setTextureAddressingMode(Ogre::TextureUnitState::TAM_CLAMP);\n    this->data->renderTarget->addListener(this);\n\n    // Camera reflection and clip plane setup\n    this->data->planeEntity->setMaterialName(\"reflection\");\n```\n\n**Material Script** I have a material called `reflection` that has a simple vertex and fragment shader. It has a texture\\_unit with its texture not yet defined, as it will be defined at runtime.\n\n```\nvertex_program reflectionV glsl\n{\n  source ../programs/reflection.vert\n}\n\nfragment_program reflectionF glsl\n{\n  source ../programs/reflection.frag\n}\n\nmaterial reflection\n{\n  technique GLSL\n  {\n    pass\n    {\n      scene_blend alpha_blend\n      vertex_program_ref reflectionV\n      {\n      }\n\n      fragment_program_ref reflectionF\n      {\n        param_named reflectMap int 0\n      }\n\n      texture_unit\n      {\n        // Will be filled in at runtime\n        // texture mytexture\n        tex_address_mode clamp\n      }\n    }\n  }\n}\n```\n\nI get the following output in ~/.gazebo/ogre.log\n\n```\n20:16:27: OGRE EXCEPTION(2:InvalidParametersException): Parameter called reflectMap does not exist.  in GpuProgramParameters::_findNamedConstantDefinition at /build/ogre-1.9-B6QkmW/ogre-1.9-1.9.0+dfsg1/OgreMain/src/OgreGpuProgramParams.cpp (line 1719)\n```\n\nThe strange thing is if I put random text into `reflection.vert` or `reflection.frag`, then it doesn\u2019t even have any errors. I believe the shaders are not even being run. I am not sure why.", "markup": "markdown", "html": "<p>In 1547:<a href=\"#!/osrf/vrx/commits/2f9414884e09\" rel=\"nofollow\" class=\"ap-connect-link\">2f9414884e09</a>, I have a very simple vertex and fragment shader. However, it is still not working.</p>\n<p><img alt=\"\" src=\"data/bitbucket.org/repo/BgXLzgM/images/1211094543-image.png\" />\nThis is what the plane looks like (does not have projectiveTexturing turned on, so it simply puts the image of the user camera onto the surface) The big black blob is actually the WAM-V in the texture. ProjectiveTexturing had to be turned off because it would not allow shader use, as per Ogre Manual:</p>\n<div class=\"codehilite\"><pre><span></span>void Ogre::TextureUnitState::setProjectiveTexturing    (    bool     enabled,\nconst Frustum *     projectionSettings = 0 \n)        \nEnables or disables projective texturing on this texture unit.\n\nRemarks\nProjective texturing allows you to generate texture coordinates based on a Frustum, which gives the impression that a texture is being projected onto the surface. Note that once you have called this method, the texture unit continues to monitor the Frustum you passed in and the projection will change if you can alter it. It also means that you must ensure that the Frustum object you pass a pointer to remains in existence for as long as this TextureUnitState does.\nThis effect cannot be combined with other texture generation effects, such as environment mapping. It also has no effect on passes which have a vertex program enabled - projective texturing has to be done in the vertex program instead.\n</pre></div>\n\n\n<p><strong>C++ Code</strong> I am simply creating a new texture called <code>mytexture</code>, setting it up with the user camera for render-to-texture, then adding this texture to the texture unit in the <code>reflection</code> material.</p>\n<div class=\"codehilite\"><pre><span></span>    <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">TexturePtr</span> <span class=\"nt\">rttTexture</span> <span class=\"o\">=</span>\n      <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">TextureManager</span><span class=\"p\">::</span><span class=\"nd\">getSingleton</span><span class=\"o\">()</span><span class=\"p\">.</span><span class=\"nc\">createManual</span><span class=\"o\">(</span>\n        <span class=\"s2\">&quot;mytexture&quot;</span><span class=\"o\">,</span>\n        <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">ResourceGroupManager</span><span class=\"p\">::</span><span class=\"nd\">DEFAULT_RESOURCE_GROUP_NAME</span><span class=\"o\">,</span>\n        <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">TEX_TYPE_2D</span><span class=\"o\">,</span>\n        <span class=\"nt\">512</span><span class=\"o\">,</span> <span class=\"nt\">512</span><span class=\"o\">,</span>\n        <span class=\"nt\">0</span><span class=\"o\">,</span>\n        <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">PF_R8G8B8</span><span class=\"o\">,</span>\n        <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">TU_RENDERTARGET</span><span class=\"o\">);</span>\n    <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">renderTarget</span> <span class=\"o\">=</span> <span class=\"nt\">rttTexture-</span><span class=\"o\">&gt;</span><span class=\"nt\">getBuffer</span><span class=\"o\">()</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">getRenderTarget</span><span class=\"o\">();</span>\n\n    <span class=\"o\">//</span> <span class=\"nt\">Setup</span> <span class=\"nt\">camera</span>\n    <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">camera</span> <span class=\"o\">=</span> <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">scene-</span><span class=\"o\">&gt;</span><span class=\"nt\">GetUserCamera</span><span class=\"o\">(</span><span class=\"nt\">0</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">OgreCamera</span><span class=\"o\">();</span>\n\n    <span class=\"o\">//</span> <span class=\"nt\">Setup</span> <span class=\"nt\">render</span> <span class=\"nt\">texture</span>\n    <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">renderTarget-</span><span class=\"o\">&gt;</span><span class=\"nt\">addViewport</span><span class=\"o\">(</span><span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">camera</span><span class=\"o\">);</span>\n    <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">renderTarget-</span><span class=\"o\">&gt;</span><span class=\"nt\">getViewport</span><span class=\"o\">(</span><span class=\"nt\">0</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">setClearEveryFrame</span><span class=\"o\">(</span><span class=\"nt\">true</span><span class=\"o\">);</span>\n    <span class=\"o\">(</span><span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">renderTarget-</span><span class=\"o\">&gt;</span><span class=\"nt\">getViewport</span><span class=\"o\">(</span><span class=\"nt\">0</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span>\n     <span class=\"nt\">setBackgroundColour</span><span class=\"o\">(</span><span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">ColourValue</span><span class=\"p\">::</span><span class=\"nd\">Black</span><span class=\"o\">));</span>\n\n    <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">MaterialPtr</span> <span class=\"nt\">renderMaterial</span> <span class=\"o\">=</span> <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">MaterialManager</span><span class=\"p\">::</span><span class=\"nd\">getSingleton</span><span class=\"o\">()</span><span class=\"p\">.</span><span class=\"nc\">getByName</span><span class=\"o\">(</span><span class=\"s2\">&quot;reflection&quot;</span><span class=\"o\">);</span>\n    <span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">TextureUnitState</span><span class=\"o\">*</span> <span class=\"nt\">t</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nt\">renderMaterial-</span><span class=\"o\">&gt;</span><span class=\"nt\">getTechnique</span><span class=\"o\">(</span><span class=\"nt\">0</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">getPass</span><span class=\"o\">(</span><span class=\"nt\">0</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">getTextureUnitState</span><span class=\"o\">(</span><span class=\"nt\">0</span><span class=\"o\">));</span>\n    <span class=\"nt\">t-</span><span class=\"o\">&gt;</span><span class=\"nt\">setTexture</span><span class=\"o\">(</span><span class=\"nt\">rttTexture</span><span class=\"o\">);</span>\n\n    <span class=\"nt\">t-</span><span class=\"o\">&gt;</span><span class=\"nt\">setTextureAddressingMode</span><span class=\"o\">(</span><span class=\"nt\">Ogre</span><span class=\"p\">::</span><span class=\"nd\">TextureUnitState</span><span class=\"p\">::</span><span class=\"nd\">TAM_CLAMP</span><span class=\"o\">);</span>\n    <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">renderTarget-</span><span class=\"o\">&gt;</span><span class=\"nt\">addListener</span><span class=\"o\">(</span><span class=\"nt\">this</span><span class=\"o\">);</span>\n\n    <span class=\"o\">//</span> <span class=\"nt\">Camera</span> <span class=\"nt\">reflection</span> <span class=\"nt\">and</span> <span class=\"nt\">clip</span> <span class=\"nt\">plane</span> <span class=\"nt\">setup</span>\n    <span class=\"nt\">this-</span><span class=\"o\">&gt;</span><span class=\"nt\">data-</span><span class=\"o\">&gt;</span><span class=\"nt\">planeEntity-</span><span class=\"o\">&gt;</span><span class=\"nt\">setMaterialName</span><span class=\"o\">(</span><span class=\"s2\">&quot;reflection&quot;</span><span class=\"o\">);</span>\n</pre></div>\n\n\n<p><strong>Material Script</strong> I have a material called <code>reflection</code> that has a simple vertex and fragment shader. It has a texture_unit with its texture not yet defined, as it will be defined at runtime.</p>\n<div class=\"codehilite\"><pre><span></span>vertex_program reflectionV glsl\n{\n  source ../programs/reflection.vert\n}\n\nfragment_program reflectionF glsl\n{\n  source ../programs/reflection.frag\n}\n\nmaterial reflection\n{\n  technique GLSL\n  {\n    pass\n    {\n      scene_blend alpha_blend\n      vertex_program_ref reflectionV\n      {\n      }\n\n      fragment_program_ref reflectionF\n      {\n        param_named reflectMap int 0\n      }\n\n      texture_unit\n      {\n        // Will be filled in at runtime\n        // texture mytexture\n        tex_address_mode clamp\n      }\n    }\n  }\n}\n</pre></div>\n\n\n<p>I get the following output in ~/.gazebo/ogre.log</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"mi\">20</span><span class=\"o\">:</span><span class=\"mi\">16</span><span class=\"o\">:</span><span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">OGRE</span> <span class=\"n\">EXCEPTION</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">InvalidParametersException</span><span class=\"o\">):</span> <span class=\"n\">Parameter</span> <span class=\"n\">called</span> <span class=\"n\">reflectMap</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">exist</span><span class=\"o\">.</span>  <span class=\"k\">in</span> <span class=\"n\">GpuProgramParameters</span><span class=\"o\">::</span><span class=\"n\">_findNamedConstantDefinition</span> <span class=\"n\">at</span> <span class=\"sr\">/build/ogre-1.9-B6QkmW/ogre-1.9-1.9.0+dfsg1/OgreMain/src/</span><span class=\"n\">OgreGpuProgramParams</span><span class=\"o\">.</span><span class=\"na\">cpp</span> <span class=\"o\">(</span><span class=\"n\">line</span> <span class=\"mi\">1719</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>The strange thing is if I put random text into <code>reflection.vert</code> or <code>reflection.frag</code>, then it doesn\u2019t even have any errors. I believe the shaders are not even being run. I am not sure why.</p>", "type": "rendered"}, "created_on": "2019-08-20T03:28:39.523126+00:00", "user": {"display_name": "Tyler Lum", "uuid": "{305d9368-23ba-4f72-b1d4-7d17d2a062d8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B305d9368-23ba-4f72-b1d4-7d17d2a062d8%7D"}, "html": {"href": "https://bitbucket.org/%7B305d9368-23ba-4f72-b1d4-7d17d2a062d8%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/5b96b66385af94340e7cabce/b8bb780f-62b7-47f8-9d03-ee65c7d17ad4/128"}}, "nickname": "tylerlum", "type": "user", "account_id": "5b96b66385af94340e7cabce"}, "updated_on": "2019-08-20T03:35:35.976944+00:00", "type": "pullrequest_comment", "id": 113651604}