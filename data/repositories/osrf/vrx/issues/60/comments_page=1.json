{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50466362.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50466362"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "Question: Currently, our notes indicate that the goal pose should be somewhere near where the vehicle starts. However, since this is a station keeping task, would it make sense to have the goal be *exactly* where the vehicle starts? If not, do we want to build in time for the vehicle to get to the goal before scoring begins?", "markup": "markdown", "html": "<p>Question: Currently, our notes indicate that the goal pose should be somewhere near where the vehicle starts. However, since this is a station keeping task, would it make sense to have the goal be <em>exactly</em> where the vehicle starts? If not, do we want to build in time for the vehicle to get to the goal before scoring begins?</p>", "type": "rendered"}, "created_on": "2019-02-06T14:56:31.968341+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 50466362}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50469951.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50469951"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "I see two advantages of using the exact position:\n\n* The task is more \"focused\", as it doesn't take into account the ability to navigate to the goal spot.\n* The plugin is simpler as you can start computing the error since the beginning.", "markup": "markdown", "html": "<p>I see two advantages of using the exact position:</p>\n<ul>\n<li>The task is more \"focused\", as it doesn't take into account the ability to navigate to the goal spot.</li>\n<li>The plugin is simpler as you can start computing the error since the beginning.</li>\n</ul>", "type": "rendered"}, "created_on": "2019-02-06T18:18:14.481791+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": null, "type": "issue_comment", "id": 50469951}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50471574.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50471574"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "Regarding the error metric: I understand we want to get something going, so I am implementing the suggestion above. However, all previous experience with distance measures makes me think this is both important and difficult to get right, so I was hesitant to invent something from scratch. I did a quick literature search to see if anyone has a combined Euclidean-distance and orientation error metric. Two useful sources discuss the more generalized case of evaluating estimated trajectories:\nhttp://rpg.ifi.uzh.ch/docs/IROS18_Zhang.pdf\nhttp://ais.informatik.uni-freiburg.de/publications/papers/sturm12iros.pdf\n\nThe use case is a little different, but we could easily apply these scoring methods to our application if they had a way of combining distance and angle errors. They don't though--it seems like everyone just calculates a separate score for each, which makes sense since there's no natural translation between them. My conclusion is that we really do have to make something up.\n\nThat said, in the draft metric formula, sqrt(dx^2+dy^2+W(dhdg^2)), it seems like the intent is to treat dhdg as its own (sort of stubby) dimension. This seems as good as anything, but if we do this, I wonder if we should do some empirical testing to give us confidence that it produces the kind of winners we want.\n\nDoes anyone have any examples / references that suggest a reasonable approach?", "markup": "markdown", "html": "<p>Regarding the error metric: I understand we want to get something going, so I am implementing the suggestion above. However, all previous experience with distance measures makes me think this is both important and difficult to get right, so I was hesitant to invent something from scratch. I did a quick literature search to see if anyone has a combined Euclidean-distance and orientation error metric. Two useful sources discuss the more generalized case of evaluating estimated trajectories:\n<a href=\"http://rpg.ifi.uzh.ch/docs/IROS18_Zhang.pdf\" rel=\"nofollow\" class=\"ap-connect-link\">http://rpg.ifi.uzh.ch/docs/IROS18_Zhang.pdf</a>\n<a href=\"http://ais.informatik.uni-freiburg.de/publications/papers/sturm12iros.pdf\" rel=\"nofollow\" class=\"ap-connect-link\">http://ais.informatik.uni-freiburg.de/publications/papers/sturm12iros.pdf</a></p>\n<p>The use case is a little different, but we could easily apply these scoring methods to our application if they had a way of combining distance and angle errors. They don't though--it seems like everyone just calculates a separate score for each, which makes sense since there's no natural translation between them. My conclusion is that we really do have to make something up.</p>\n<p>That said, in the draft metric formula, sqrt(dx^2+dy^2+W(dhdg^2)), it seems like the intent is to treat dhdg as its own (sort of stubby) dimension. This seems as good as anything, but if we do this, I wonder if we should do some empirical testing to give us confidence that it produces the kind of winners we want.</p>\n<p>Does anyone have any examples / references that suggest a reasonable approach?</p>", "type": "rendered"}, "created_on": "2019-02-06T20:20:10.830127+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 50471574}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50473034.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50473034"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "The `sqrt(dx^2+dy^2+W(dhdg^2))` looks like a good approach to me based on your research and our previous discussions. It confirms that we need two treat each dimension in an independent way and combine them with some coheficient Use your own judgement for the initial weights and we'll tune them when we gain more experience.", "markup": "markdown", "html": "<p>The <code>sqrt(dx^2+dy^2+W(dhdg^2))</code> looks like a good approach to me based on your research and our previous discussions. It confirms that we need two treat each dimension in an independent way and combine them with some coheficient Use your own judgement for the initial weights and we'll tune them when we gain more experience.</p>", "type": "rendered"}, "created_on": "2019-02-06T22:32:24.451519+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": null, "type": "issue_comment", "id": 50473034}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50487898.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50487898"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "I agree that the draft metric formula is a good start - certainly good to start simple.  I'd think that weights in the range of W={1.0-10.0}  would be reasonable.\n\nAs for the initial position,  I believe our consideration to initialize at a position near the goal was to avoid inadvertently providing additional information that would allow folks circumvent fusing the sensors with a navigation estimate.  I agree that for now we can have the initial position be exactly the goal, but we may want to later add a small random offset, where 'small' is on the order of the sensor noise.", "markup": "markdown", "html": "<p>I agree that the draft metric formula is a good start - certainly good to start simple.  I'd think that weights in the range of W={1.0-10.0}  would be reasonable.</p>\n<p>As for the initial position,  I believe our consideration to initialize at a position near the goal was to avoid inadvertently providing additional information that would allow folks circumvent fusing the sensors with a navigation estimate.  I agree that for now we can have the initial position be exactly the goal, but we may want to later add a small random offset, where 'small' is on the order of the sensor noise.</p>", "type": "rendered"}, "created_on": "2019-02-07T16:24:30.225992+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 50487898}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50492458.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50492458"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "OK, I pushed an update that implements what is described in the first post with no weights for right now. I still have some reservations about the scoring metric--I think the main motivation for the choice of Euclidean distance is to get something that seems \"natural\" but I don't think there's really a natural metric for what we are trying to measure, and this approach seems to incentivize some odd behavior. For example, if a drift away from the goal, a common-sense response would be to turn around and head back to it. Then, once I'm in the right place (or at least close) I would probably work on keeping the correct orientation.\n\nIn our case, if we are always scoring offset and orientation error simultaneously, it would be better for me to keep my orientation as correct as possible the whole time, while trying to slide myself back toward the goal position. This seems to give the holonomic configuration a big advantage. It also seems like it rewards a capability that, at least from my limited perspective, does not appear to be very important. Also, while this may not be a huge problem for stationkeeping (assuming the vehicles can stay relatively close to the goal throughout) it will show up again if we re-use this metric during the wayfinding task.\n\nWe can probably improve the situation with a clever weighting scheme (especially if the weight is also a function of position) but I think we will be fighting the bias of the model. Instead, I would advocate embracing the game-like nature of the challenge, and using a more obviously artificial scoring system. I have an idea for an alternative scoring that I'd like to propose (once I get it written up).", "markup": "markdown", "html": "<p>OK, I pushed an update that implements what is described in the first post with no weights for right now. I still have some reservations about the scoring metric--I think the main motivation for the choice of Euclidean distance is to get something that seems \"natural\" but I don't think there's really a natural metric for what we are trying to measure, and this approach seems to incentivize some odd behavior. For example, if a drift away from the goal, a common-sense response would be to turn around and head back to it. Then, once I'm in the right place (or at least close) I would probably work on keeping the correct orientation.</p>\n<p>In our case, if we are always scoring offset and orientation error simultaneously, it would be better for me to keep my orientation as correct as possible the whole time, while trying to slide myself back toward the goal position. This seems to give the holonomic configuration a big advantage. It also seems like it rewards a capability that, at least from my limited perspective, does not appear to be very important. Also, while this may not be a huge problem for stationkeeping (assuming the vehicles can stay relatively close to the goal throughout) it will show up again if we re-use this metric during the wayfinding task.</p>\n<p>We can probably improve the situation with a clever weighting scheme (especially if the weight is also a function of position) but I think we will be fighting the bias of the model. Instead, I would advocate embracing the game-like nature of the challenge, and using a more obviously artificial scoring system. I have an idea for an alternative scoring that I'd like to propose (once I get it written up).</p>", "type": "rendered"}, "created_on": "2019-02-07T21:55:39.746657+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 50492458}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60/comments/50839168.json"}, "html": {"href": "#!/osrf/vrx/issues/60#comment-50839168"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/60.json"}}, "type": "issue", "id": 60, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Station Keeping Scoring Plugin"}, "content": {"raw": "I believe this is resolved with PR #67", "markup": "markdown", "html": "<p>I believe this is resolved with <a href=\"#!/osrf/vrx/pull-requests/67/station-keeping-task\" rel=\"nofollow\" class=\"ap-connect-link\">PR #67</a></p>", "type": "rendered"}, "created_on": "2019-03-01T04:52:46.008326+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 50839168}], "page": 1, "size": 7}