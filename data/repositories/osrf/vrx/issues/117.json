{"priority": "major", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "links": {"attachments": {"href": "data/repositories/osrf/vrx/issues/117/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/vrx/issues/117.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/vrx/issues/117/watch"}, "comments": {"href": "data/repositories/osrf/vrx/issues/117/comments_page=1.json"}, "html": {"href": "#!/osrf/vrx/issues/117/clarify-how-perception-task-handles-timing"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/vrx/issues/117/vote"}}, "reporter": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "title": "Clarify how perception task handles timing of submissions", "component": null, "votes": 0, "watches": 1, "content": {"raw": "The behavior of the scoring plugin appears to be that it only allows the team to submit an answer while the object in question is still visible \\(i.e. before the next object appears\\). Given that we will only score the first answer, it seems like the optimal solution would want to take advantage of the full window before giving an answer, but would need to make sure it doesn't answer too late. However, we don't give any indication of when the object is going to go away, so this is hard to guess. I think there are a few solutions we might consider:\r\n\r\n1. Simply state that every object will be visible for some fixed amount of time. For example, it looks like we currently switch every 5 seconds, so we could just document that this is the time.\r\n2. If the time is meant to be variable, we can give some indication that an object is about to go away--either by publishing a message or giving a visual indication.\r\n3. Ignore the time of submission and simply score the submissions in order. In this version, the objects would still appear and disappear at any speeds \\(or variable speeds\\), and teams can submit solutions any time before the onFinished state arrives. \r\n\r\nMy preference is option 3 because it seems relatively simple to implement and allows us to vary the difficulty of the task over different runs. Option 2 seems like the most complicated.  \r\n  \r\nOf course, I doubt the above list is exhaustive. Other ideas?", "markup": "markdown", "html": "<p>The behavior of the scoring plugin appears to be that it only allows the team to submit an answer while the object in question is still visible (i.e. before the next object appears). Given that we will only score the first answer, it seems like the optimal solution would want to take advantage of the full window before giving an answer, but would need to make sure it doesn't answer too late. However, we don't give any indication of when the object is going to go away, so this is hard to guess. I think there are a few solutions we might consider:</p>\n<ol>\n<li>Simply state that every object will be visible for some fixed amount of time. For example, it looks like we currently switch every 5 seconds, so we could just document that this is the time.</li>\n<li>If the time is meant to be variable, we can give some indication that an object is about to go away--either by publishing a message or giving a visual indication.</li>\n<li>Ignore the time of submission and simply score the submissions in order. In this version, the objects would still appear and disappear at any speeds (or variable speeds), and teams can submit solutions any time before the onFinished state arrives. </li>\n</ol>\n<p>My preference is option 3 because it seems relatively simple to implement and allows us to vary the difficulty of the task over different runs. Option 2 seems like the most complicated.  </p>\n<p>Of course, I doubt the above list is exhaustive. Other ideas?</p>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": null, "edited_on": null, "created_on": "2019-06-21T18:33:10.076009+00:00", "milestone": {"name": "1.1", "links": {"self": {"href": "data/repositories/osrf/vrx/milestones/363172.json"}}}, "updated_on": "2019-07-01T23:48:11.163410+00:00", "type": "issue", "id": 117}