{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111/comments/52697690.json"}, "html": {"href": "#!/osrf/vrx/issues/111#comment-52697690"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111.json"}}, "type": "issue", "id": 111, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Finish criteria for scoring plugins."}, "content": {"raw": "After reviewing each of the tasks and the scoring criteria, I think we can achieve the effect we want using currently available functionality. Below is a description of how this could work for each of the tasks mentioned. Please take a look and let me know if you think the proposed solutions are workable.\n\n### Wayfinding Task\n\n**Scoring:** rank order based on weighted combination of overall state error and elapsed simulation time.\n\n* **Requirements:** Teams must be able to declare \u201cfinished,\u201d probably by  calling a service.\n* **Alternative:** It is unlikely that there will be a tie in the overall state error, so we could dispense with the simulation time factor entirely. \n\n    * In addition to eliminating the need for a service, this eliminates the need to invent a weighting function that mixes time and error.\n    * If we want to reward  teams that solve the task more quickly we can just keep the time fixed and place the waypoints farther apart.\n    \n\n### Navigation Channel\n\n**Scoring:** Currently we say the run score is the sum of successful gates traversed minus the number of collisions. Finish-time is used as a tie-breaker.\n\n* **Requirements:** State should transition to finish when the vehicle finishes navigating the course.\n\n    * **Proposed:** A vehicle has \u201cfinished\u201d the course if it has passed through the start gate and the end gate \\(in that order\\).\n    * **Justification:** Teams must be allowed to miss gates, or our scoring criteria becomes confusing. However, unlike the Wayfinding task, teams should not be able to simply end the task by declaring that they are finished, since this opens up many possibilities for abuse \\(for example, declaring \u201cfinished\u201d immediately\\).\n    \n* **Alternative:** Given the criteria above, there is no need to implement a state transition to the \u201cfinished\u201d state. We can use the timestamps associated with each gate to determine who finished the fastest.\n\n    * Note that this criteria also works in the event that we revert to the original time-based scoring method.\n    \n\n### Docking Task\n\n**Scoring:** Points are accumulated for docking, docking in the correct dock, and reporting the correct color sequence. Finish-time is used as a tie-breaker.\n\n* **Requirements:** There are two ways to determine when the task is finished.\n\n    1. The team declares they are finished.\n    2. The team docks successfully in any dock.\n    \n* The case for option 2: \n\n    * It is simple to implement and does not require additional functionality.\n    * It seems to align with the goals of the task.\n    * In contrast, the only clear advantage of option 1 is that it allows a team to make multiple attempts if desired. However, in most cases it does not make sense to allow this. For example: \n    \n        * We don\u2019t want teams to hedge their bets by docking in multiple bays.\n        * We don\u2019t want to award extra points for docking multiple times in the same bay.\n        \n    * Even if we do want to allow multiple attempts, this can be done by modifying option 2 so the task is finished on the last completed / valid / successful docking  \\(defined as entering a bay, waiting the correct amount of time, and exiting\\). Whether it makes sense to do this depends on how we are handling collisions \\(see below\\).\n    \n* **Alternative:** Instead of transitioning to the finished state, just look at the time associated with the first or last successful docking attempt \\(depending on whether multiple attempts should be allowed\\).\n\n### Extra Note about Docking Tasking: Collisions\n\n* We currently don\u2019t say anything about how we handle collisions, but we probably need to implement some penalty to discourage using the dock as a braking mechanism. \n* In my view, how the task handles collisions is crucial for determining whether multiple docking attempts should be allowed.\n* For example:\n\n    * If collisions result in some point deductions, we should probably only allow one docking attempt \\(since otherwise there is nothing to be gained from a second attempt, unless we allow teams to score multiple times for consecutive dockings, which seems to get away from the stated plan\\). \n    * If collisions \u201cinvalidate\u201d a docking attempt, then it seems to make sense to allow teams to try again.\n    \n\n### Conclusion\n\nIf the above alternatives are acceptable, we can implement the scoring using the current functionality \\(possibly with some minor changes to get timestamps for events\\) and we don\u2019t have to add anything to the API or require teams to send additional messages.\n\nHope this is helpful. Let me know what you all think!", "markup": "markdown", "html": "<p>After reviewing each of the tasks and the scoring criteria, I think we can achieve the effect we want using currently available functionality. Below is a description of how this could work for each of the tasks mentioned. Please take a look and let me know if you think the proposed solutions are workable.</p>\n<h3 id=\"markdown-header-wayfinding-task\">Wayfinding Task</h3>\n<p><strong>Scoring:</strong> rank order based on weighted combination of overall state error and elapsed simulation time.</p>\n<ul>\n<li><strong>Requirements:</strong> Teams must be able to declare \u201cfinished,\u201d probably by  calling a service.</li>\n<li>\n<p><strong>Alternative:</strong> It is unlikely that there will be a tie in the overall state error, so we could dispense with the simulation time factor entirely. </p>\n<ul>\n<li>In addition to eliminating the need for a service, this eliminates the need to invent a weighting function that mixes time and error.</li>\n<li>If we want to reward  teams that solve the task more quickly we can just keep the time fixed and place the waypoints farther apart.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"markdown-header-navigation-channel\">Navigation Channel</h3>\n<p><strong>Scoring:</strong> Currently we say the run score is the sum of successful gates traversed minus the number of collisions. Finish-time is used as a tie-breaker.</p>\n<ul>\n<li>\n<p><strong>Requirements:</strong> State should transition to finish when the vehicle finishes navigating the course.</p>\n<ul>\n<li><strong>Proposed:</strong> A vehicle has \u201cfinished\u201d the course if it has passed through the start gate and the end gate (in that order).</li>\n<li><strong>Justification:</strong> Teams must be allowed to miss gates, or our scoring criteria becomes confusing. However, unlike the Wayfinding task, teams should not be able to simply end the task by declaring that they are finished, since this opens up many possibilities for abuse (for example, declaring \u201cfinished\u201d immediately).</li>\n</ul>\n</li>\n<li>\n<p><strong>Alternative:</strong> Given the criteria above, there is no need to implement a state transition to the \u201cfinished\u201d state. We can use the timestamps associated with each gate to determine who finished the fastest.</p>\n<ul>\n<li>Note that this criteria also works in the event that we revert to the original time-based scoring method.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"markdown-header-docking-task\">Docking Task</h3>\n<p><strong>Scoring:</strong> Points are accumulated for docking, docking in the correct dock, and reporting the correct color sequence. Finish-time is used as a tie-breaker.</p>\n<ul>\n<li>\n<p><strong>Requirements:</strong> There are two ways to determine when the task is finished.</p>\n<ol>\n<li>The team declares they are finished.</li>\n<li>The team docks successfully in any dock.</li>\n</ol>\n</li>\n<li>\n<p>The case for option 2: </p>\n<ul>\n<li>It is simple to implement and does not require additional functionality.</li>\n<li>It seems to align with the goals of the task.</li>\n<li>\n<p>In contrast, the only clear advantage of option 1 is that it allows a team to make multiple attempts if desired. However, in most cases it does not make sense to allow this. For example: </p>\n<ul>\n<li>We don\u2019t want teams to hedge their bets by docking in multiple bays.</li>\n<li>We don\u2019t want to award extra points for docking multiple times in the same bay.</li>\n</ul>\n</li>\n<li>\n<p>Even if we do want to allow multiple attempts, this can be done by modifying option 2 so the task is finished on the last completed / valid / successful docking  (defined as entering a bay, waiting the correct amount of time, and exiting). Whether it makes sense to do this depends on how we are handling collisions (see below).</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Alternative:</strong> Instead of transitioning to the finished state, just look at the time associated with the first or last successful docking attempt (depending on whether multiple attempts should be allowed).</p>\n</li>\n</ul>\n<h3 id=\"markdown-header-extra-note-about-docking-tasking-collisions\">Extra Note about Docking Tasking: Collisions</h3>\n<ul>\n<li>We currently don\u2019t say anything about how we handle collisions, but we probably need to implement some penalty to discourage using the dock as a braking mechanism. </li>\n<li>In my view, how the task handles collisions is crucial for determining whether multiple docking attempts should be allowed.</li>\n<li>\n<p>For example:</p>\n<ul>\n<li>If collisions result in some point deductions, we should probably only allow one docking attempt (since otherwise there is nothing to be gained from a second attempt, unless we allow teams to score multiple times for consecutive dockings, which seems to get away from the stated plan). </li>\n<li>If collisions \u201cinvalidate\u201d a docking attempt, then it seems to make sense to allow teams to try again.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"markdown-header-conclusion\">Conclusion</h3>\n<p>If the above alternatives are acceptable, we can implement the scoring using the current functionality (possibly with some minor changes to get timestamps for events) and we don\u2019t have to add anything to the API or require teams to send additional messages.</p>\n<p>Hope this is helpful. Let me know what you all think!</p>", "type": "rendered"}, "created_on": "2019-06-23T03:39:17.498349+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 52697690}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111/comments/52738237.json"}, "html": {"href": "#!/osrf/vrx/issues/111#comment-52738237"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111.json"}}, "type": "issue", "id": 111, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Finish criteria for scoring plugins."}, "content": {"raw": "I agree with Michael, sounds like we should be able to implement scoring without adding extra functionality. Let\u2019s keep it simple!", "markup": "markdown", "html": "<p>I agree with Michael, sounds like we should be able to implement scoring without adding extra functionality. Let\u2019s keep it simple!</p>", "type": "rendered"}, "created_on": "2019-06-26T04:50:33.521134+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": null, "type": "issue_comment", "id": 52738237}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111/comments/52749098.json"}, "html": {"href": "#!/osrf/vrx/issues/111#comment-52749098"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111.json"}}, "type": "issue", "id": 111, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Finish criteria for scoring plugins."}, "content": {"raw": "Concur.", "markup": "markdown", "html": "<p>Concur.</p>", "type": "rendered"}, "created_on": "2019-06-26T16:47:54.400934+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 52749098}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111/comments/52810963.json"}, "html": {"href": "#!/osrf/vrx/issues/111#comment-52810963"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/111.json"}}, "type": "issue", "id": 111, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Finish criteria for scoring plugins."}, "content": {"raw": "Scoring criteria is now in the VRX Competition and Task Descriptions document", "markup": "markdown", "html": "<p>Scoring criteria is now in the VRX Competition and Task Descriptions document</p>", "type": "rendered"}, "created_on": "2019-07-02T01:54:17.635872+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 52810963}], "page": 1, "size": 4}