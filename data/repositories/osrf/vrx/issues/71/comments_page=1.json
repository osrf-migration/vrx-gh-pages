{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50853147.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50853147"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2019-03-01T20:25:20.598747+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 50853147}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50913807.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50913807"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": "I went back to look at this and realized that the tutorial in question is only intended to cover the case where someone wants to build the image using the latest source code (I had been thinking we also needed to cover the run-only case). Anyway, this means we have to download and compile our repository at some point. The problem is just that under option 2 we're doing it twice: once when we pull the build and run scripts, and once when we actually build the image. In my opinion, this needs to change anyway because re-running the build script will only rebuild the code if something in the Dockerfile changes (since that is all Docker is able to detect). This means that if people don't manually wipe out their stale layers (or delete the old images) the image won't update, which defeats the purpose of this use-case. It seems like too much to expect people to do this, and even if they do they will continue to have to build the last several layers from scratch, which is way worse than the one-time cost of downloading the repo on the host.\n\nWhat should happen instead, I think, is a modified version of 2 (above) which eliminates the duplication by making some changes to the Dockerfile. The workflow is roughly like this:\n\n1. Download the whole repo once on the host.\n1. Run the build script.\n1. The Dockerfile is altered so instead of downloading the repository, it expects to pull in all the files it needs from the local file system (that is, it assumes it is sitting in the subdirectory where we keep it in the repo).\n1. The Dockerfile builds the code using the copied files, then deletes the copies before finishing the image.\n1. Finally, the run script mounts the local repository into the image at runtime.\n\nThis might seem a bit more complicated but I think most of the complexity is hidden from the user and it gets the behavior we want. That is, we build the image the first time using the latest version of the code, and any subsequent pulls or updates will be immediately available in the image. Furthermore, all the time-saving features of our build tools should work properly. If that sounds good I can make a branch so we can test it to make sure it behaves as I claim it will. :)", "markup": "markdown", "html": "<p>I went back to look at this and realized that the tutorial in question is only intended to cover the case where someone wants to build the image using the latest source code (I had been thinking we also needed to cover the run-only case). Anyway, this means we have to download and compile our repository at some point. The problem is just that under option 2 we're doing it twice: once when we pull the build and run scripts, and once when we actually build the image. In my opinion, this needs to change anyway because re-running the build script will only rebuild the code if something in the Dockerfile changes (since that is all Docker is able to detect). This means that if people don't manually wipe out their stale layers (or delete the old images) the image won't update, which defeats the purpose of this use-case. It seems like too much to expect people to do this, and even if they do they will continue to have to build the last several layers from scratch, which is way worse than the one-time cost of downloading the repo on the host.</p>\n<p>What should happen instead, I think, is a modified version of 2 (above) which eliminates the duplication by making some changes to the Dockerfile. The workflow is roughly like this:</p>\n<ol>\n<li>Download the whole repo once on the host.</li>\n<li>Run the build script.</li>\n<li>The Dockerfile is altered so instead of downloading the repository, it expects to pull in all the files it needs from the local file system (that is, it assumes it is sitting in the subdirectory where we keep it in the repo).</li>\n<li>The Dockerfile builds the code using the copied files, then deletes the copies before finishing the image.</li>\n<li>Finally, the run script mounts the local repository into the image at runtime.</li>\n</ol>\n<p>This might seem a bit more complicated but I think most of the complexity is hidden from the user and it gets the behavior we want. That is, we build the image the first time using the latest version of the code, and any subsequent pulls or updates will be immediately available in the image. Furthermore, all the time-saving features of our build tools should work properly. If that sounds good I can make a branch so we can test it to make sure it behaves as I claim it will. :)</p>", "type": "rendered"}, "created_on": "2019-03-06T05:20:00.930544+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 50913807}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50926841.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50926841"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": "I agree with the sentiment.  It seems that this gets complicated because we are using a single Dockerfile for (at least) a couple different use cases: (1) automated build of the standard images for dockerhub and (2) user builds of image for use with the latest VRX code.  \n\nIn the comment above, steps 3 and 4 seem like they might be a bit complicated.  For 3, the assumption of filesystem location of the repo could be an issue.  Step 4 (build then delete) seems a bit wasteful.\n\nAs an alternative, would it make sense to have a single Dockerfile for both use cases.  For the automatic docker release builds (our standard release images) VRX is cloned and build within the container (no mounts to the a local filesystem).  For the second use case (building the latest VRX) there is a conditional in the Dockerfile that prevents the VRX clone/build within the container - so VRX isn't built during the container build step, but instead is build by the user.  Then we provide tutorial instructions on steps for the user to run the image and mount  a host directory containing the VRX repo. \n\nIt does look like conditionals within Dockerfiles are a bit clunky  \n\nAffording this second workflow might have the added benefit of giving teams a working example of how to use Docker for setting up their own software - where they will be doing active development.  Since they are going to  need to submit their software via a Docker container, this may help them along that path.", "markup": "markdown", "html": "<p>I agree with the sentiment.  It seems that this gets complicated because we are using a single Dockerfile for (at least) a couple different use cases: (1) automated build of the standard images for dockerhub and (2) user builds of image for use with the latest VRX code.  </p>\n<p>In the comment above, steps 3 and 4 seem like they might be a bit complicated.  For 3, the assumption of filesystem location of the repo could be an issue.  Step 4 (build then delete) seems a bit wasteful.</p>\n<p>As an alternative, would it make sense to have a single Dockerfile for both use cases.  For the automatic docker release builds (our standard release images) VRX is cloned and build within the container (no mounts to the a local filesystem).  For the second use case (building the latest VRX) there is a conditional in the Dockerfile that prevents the VRX clone/build within the container - so VRX isn't built during the container build step, but instead is build by the user.  Then we provide tutorial instructions on steps for the user to run the image and mount  a host directory containing the VRX repo. </p>\n<p>It does look like conditionals within Dockerfiles are a bit clunky  </p>\n<p>Affording this second workflow might have the added benefit of giving teams a working example of how to use Docker for setting up their own software - where they will be doing active development.  Since they are going to  need to submit their software via a Docker container, this may help them along that path.</p>", "type": "rendered"}, "created_on": "2019-03-06T17:54:17.082372+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 50926841}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50935907.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50935907"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": "I think we are actually mostly in agreement about what is supposed to happen, but I may have caused some confusion by loose comments about use-cases and file-system assumptions. After some effort trying to clarify in a comment, I gave up and just implemented the approach I'm attempting to describe in the docker-workflow branch. I think if you wouldn't mind trying it out, that would make discussion less complicated.\n \nUsing that branch the tutorial for building your own image would look like this:\n\n1. hg clone #!/osrf/vrx\n1. cd vrx\n1. docker/build.bash .\n1. docker/run.bash vrx\n\nThe Nvidia version is the same but with the -n options added to the scripts and the altered image name. Users who want to modify the code and rebuild can now just edit the files locally and then re-run the build and run scripts. This doesn't require a mount because COPY will detect the changes and rebuild from the appropriate layer. Overall, it's pretty fast and simple. On my machine it takes about 35 seconds to rebuild.\n\nIn addition, the build process itself is faster because copying the files from the local directory (as opposed to pulling them from mercurial) is nearly instantaneous. Our repository only has about 10MB of data in it, so transferring this in and out of the container from the local file system is basically free.\n\nCurrently, the code in this branch does not delete the copied files from the image. However, I recommend that we do this because 1) it takes almost no time and 2) it avoids confusion in the more-advanced use case where the user wants to bind-mount the repository. It also creates a slightly leaner image (though only by 10 MB, or 1% of the 1GB total, so this probably isn't crucial).\n\nI agree we should make a separate tutorial for the workflow involving the bind mount. It is totally optional but does have some nice advantages.\n\nHopefully this is all clearer than in my first attempt. There are two points in particular I should emphasize just to make sure we are on the same page: \n\n1. These changes will have no impact on the use-case where the user is just running the pre-built image. They will, as before, just download it and run it.\n1. No extra requirements are introduced about the location of the code in the file system. The only thing that is required is that you clone the repository first and run the scripts from the root of the repository instead of from the docker subfolder. This results in:\n    * less data crossing the network overall, since the image is no longer cloning the repository in the build process (including the Docker scripts which were already downloaded), and\n    * a simpler tutorial.", "markup": "markdown", "html": "<p>I think we are actually mostly in agreement about what is supposed to happen, but I may have caused some confusion by loose comments about use-cases and file-system assumptions. After some effort trying to clarify in a comment, I gave up and just implemented the approach I'm attempting to describe in the docker-workflow branch. I think if you wouldn't mind trying it out, that would make discussion less complicated.</p>\n<p>Using that branch the tutorial for building your own image would look like this:</p>\n<ol>\n<li>hg clone <a href=\"#!/osrf/vrx\" rel=\"nofollow\" class=\"ap-connect-link\">#!/osrf/vrx</a></li>\n<li>cd vrx</li>\n<li>docker/build.bash .</li>\n<li>docker/run.bash vrx</li>\n</ol>\n<p>The Nvidia version is the same but with the -n options added to the scripts and the altered image name. Users who want to modify the code and rebuild can now just edit the files locally and then re-run the build and run scripts. This doesn't require a mount because COPY will detect the changes and rebuild from the appropriate layer. Overall, it's pretty fast and simple. On my machine it takes about 35 seconds to rebuild.</p>\n<p>In addition, the build process itself is faster because copying the files from the local directory (as opposed to pulling them from mercurial) is nearly instantaneous. Our repository only has about 10MB of data in it, so transferring this in and out of the container from the local file system is basically free.</p>\n<p>Currently, the code in this branch does not delete the copied files from the image. However, I recommend that we do this because 1) it takes almost no time and 2) it avoids confusion in the more-advanced use case where the user wants to bind-mount the repository. It also creates a slightly leaner image (though only by 10 MB, or 1% of the 1GB total, so this probably isn't crucial).</p>\n<p>I agree we should make a separate tutorial for the workflow involving the bind mount. It is totally optional but does have some nice advantages.</p>\n<p>Hopefully this is all clearer than in my first attempt. There are two points in particular I should emphasize just to make sure we are on the same page: </p>\n<ol>\n<li>These changes will have no impact on the use-case where the user is just running the pre-built image. They will, as before, just download it and run it.</li>\n<li>No extra requirements are introduced about the location of the code in the file system. The only thing that is required is that you clone the repository first and run the scripts from the root of the repository instead of from the docker subfolder. This results in:<ul>\n<li>less data crossing the network overall, since the image is no longer cloning the repository in the build process (including the Docker scripts which were already downloaded), and</li>\n<li>a simpler tutorial.</li>\n</ul>\n</li>\n</ol>", "type": "rendered"}, "created_on": "2019-03-07T08:21:14.931753+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 50935907}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50948805.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50948805"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": "This discussion is helpful, thank you for your patience.  New to docker and trying to come up to speed.\n\nIt sounds like there are two options here.  \n\n## Option 1: Copy\n\nThis is the option described above.  The VRX repo is copied from the host to the container during the container build.\n\nPro:\n\n    * Building VRX happens as part of building the Docker container\n    * Fewer steps for the user\n\nCon:\n\n    *  Modifications to VRX require rebuilding the image.  For me, I think this would be problematic for development.   I typically have a number of terminals connected to the images.  Making any change, even to an xacro file, would require me to shut everything down, rebuild the image, and restart the images, join a few terminals, etc.\n\n## Option 2: Mount\n\nIn this option the image would be independent of the VRX software, requiring a two step process: build the image, then clone/build VRX\n\nPro: \n\n    * Modifications to VRX only requires rebuilding VRX, not the Docker image.\n\nCon: \n\n    * More initial steps for new users\n    * More complicated tutorial\n\n\n## Summary\n\nI guess it comes down to if we think there is a use case where folks would want to build the VRX software from the latest source, but wouldn't want/need to make any changes to VRX?\n\nLet's discuss at our meeting in a couple hours...", "markup": "markdown", "html": "<p>This discussion is helpful, thank you for your patience.  New to docker and trying to come up to speed.</p>\n<p>It sounds like there are two options here.  </p>\n<h2 id=\"markdown-header-option-1-copy\">Option 1: Copy</h2>\n<p>This is the option described above.  The VRX repo is copied from the host to the container during the container build.</p>\n<p>Pro:</p>\n<div class=\"codehilite\"><pre><span></span>* Building VRX happens as part of building the Docker container\n* Fewer steps for the user\n</pre></div>\n\n\n<p>Con:</p>\n<div class=\"codehilite\"><pre><span></span>*  Modifications to VRX require rebuilding the image.  For me, I think this would be problematic for development.   I typically have a number of terminals connected to the images.  Making any change, even to an xacro file, would require me to shut everything down, rebuild the image, and restart the images, join a few terminals, etc.\n</pre></div>\n\n\n<h2 id=\"markdown-header-option-2-mount\">Option 2: Mount</h2>\n<p>In this option the image would be independent of the VRX software, requiring a two step process: build the image, then clone/build VRX</p>\n<p>Pro: </p>\n<div class=\"codehilite\"><pre><span></span>* Modifications to VRX only requires rebuilding VRX, not the Docker image.\n</pre></div>\n\n\n<p>Con: </p>\n<div class=\"codehilite\"><pre><span></span>* More initial steps for new users\n* More complicated tutorial\n</pre></div>\n\n\n<h2 id=\"markdown-header-summary\">Summary</h2>\n<p>I guess it comes down to if we think there is a use case where folks would want to build the VRX software from the latest source, but wouldn't want/need to make any changes to VRX?</p>\n<p>Let's discuss at our meeting in a couple hours...</p>", "type": "rendered"}, "created_on": "2019-03-07T20:47:13.659276+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 50948805}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50949665.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50949665"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": "Yes, great--thanks for going through it all. Those two options are correct but they are also compatible. This because COPY operates at build time and mount operates at runtime. So, you start with the COPY option to get your image created. (You have to do this because you can't mount things at build time.) Then, when you run your image, you mount the version of the repository you already pulled down. If we mount it to the  vrx_ws/src/vrx directory in the container, the environment in the container will appear exactly the same, but updates to the repository will be instantly available. Likewise, running catkin_make from inside the container will update the container without having to rebuild it, as you point out. I think this gets you the best of both worlds.", "markup": "markdown", "html": "<p>Yes, great--thanks for going through it all. Those two options are correct but they are also compatible. This because COPY operates at build time and mount operates at runtime. So, you start with the COPY option to get your image created. (You have to do this because you can't mount things at build time.) Then, when you run your image, you mount the version of the repository you already pulled down. If we mount it to the  vrx_ws/src/vrx directory in the container, the environment in the container will appear exactly the same, but updates to the repository will be instantly available. Likewise, running catkin_make from inside the container will update the container without having to rebuild it, as you point out. I think this gets you the best of both worlds.</p>", "type": "rendered"}, "created_on": "2019-03-07T21:58:58.197079+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 50949665}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/50950366.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-50950366"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2019-03-07T23:30:58.004473+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "updated_on": null, "type": "issue_comment", "id": 50950366}, {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71/comments/51629306.json"}, "html": {"href": "#!/osrf/vrx/issues/71#comment-51629306"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/71.json"}}, "type": "issue", "id": 71, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Workflow for docker"}, "content": {"raw": "The tutorials have been updated to incorporate this proposal.", "markup": "markdown", "html": "<p>The tutorials have been updated to incorporate this proposal.</p>", "type": "rendered"}, "created_on": "2019-04-13T03:43:41.407010+00:00", "user": {"display_name": "Michael McCarrin", "uuid": "{3c3f500d-bbf6-472c-b8f7-627e5eabc226}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D"}, "html": {"href": "https://bitbucket.org/%7B3c3f500d-bbf6-472c-b8f7-627e5eabc226%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/a50abc93a3175f92c79e7521dfe089c0d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMM-0.png"}}, "nickname": "m1chaelm", "type": "user", "account_id": "5b2a9176467c9a09caa71ab1"}, "updated_on": null, "type": "issue_comment", "id": 51629306}], "page": 1, "size": 8}