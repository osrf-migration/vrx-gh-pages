{"links": {"self": {"href": "data/repositories/osrf/vrx/issues/23/comments/50911053.json"}, "html": {"href": "#!/osrf/vrx/issues/23#comment-50911053"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/23.json"}}, "type": "issue", "id": 23, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Coordinate the physics and visualization of the wave field"}, "content": {"raw": "Rhys provided a very interesting solution in the [asv_wave_sim](https://github.com/srmainwaring/asv_wave_sim) project.  Going through that project, there are two significant innovations:\n\n1.  The visualization and physics share a common wave field.  This is done by having a WavefieldModelPlugin associated with the Ocean model.  Two WavefieldVisualPlugins request the wave field parameters via Gazebo messages which then drives the OpenGL shader.  The HydrodynamicsPlugin associated with the physical objects within the wave field access a shared WavefieldEntity pointer which is used to access a Wavefield object directly from the WavefieldModelPlugin.\n2. The buoyancy calculation is generalized to use triangle meshes as described in Jacques Kerner's two part blog describing boat physics for games - see [asv_wave_sim](https://github.com/srmainwaring/asv_wave_sim) Acknowledgments.\n\nThe WAM-V geometry (twin cylindrical hulls) is sufficiently simple that, as a first step, we might consider Rhys's synchronization of the visual and physical (1) without adding the complexity of mesh-based buoyancy (2).  This might also allow us to avoid licensing issues associated with using CGAL.\n\nHere is my notes from going through the code...\n\n------------------------------------------------------\n\n# asv_wave_sim Explanation\n\n## Model: ocean_waves\n\nThe `ocean_waves` model includes three plugins:\n\n 1. WavefieldModelPlugin, inherits from ModelPlugin.  Instantiates a WavefieldEntity and a Wavefield object.  Wave field parameters are passed to the Wavefield object.  Subscribes to Gazebo message on `~/request`.  When receives message, responds on `~/response` with wave field parameters.\n 2. A WavefieldVisualPlugin for the water surface, inherits from VisualPlugin.  Requests wave parameters from the WavefieldModelPlugin via Gazebo message.  Uses `rendering` API to set input parameters to OpenGL shader GernstnerWaves.frag.\n 3. Another  WavefieldVisualPlugin for below the water surface.  Uses the same parameters and shader. \n\n### WavefieldModelPlugin, OnUpdate\n\nThe update is throttled to a nominal 30 Hz.  The WavefieldEntity is updated, which calls the Wavefield Update and UpdateGerstnerWave methods.  The Wavfield UpdateGerstnerWave method modifies the underlying CGAL Surface_mesh object based on the Gerstner wave model for the water surface.\n\n## Model: box\n\nFor objects within the wave field, the HydrodynamicsPlugin, a ModelPlugin, connects the object to the wave field.  The `wave_model` plugin parameter specifies the name of the model that includes the WavefieldModelPlugin.\n\n### HydrodynamicsPlugin, Init\n\nCalls InitPhysics() which retrieves the specified ModelPtr by name, which then gets the a pointer to a WavefieldEntity object from within the WavefieldModelPlugin.  Finally calls the WavefieldEntity GetWaveField method to return a shared pointer to the Wavefield object.\n\nCreates a vector of HydrodynamicsLinkData objects, one for each link in the model.  Each HydrodynamicsLinkData objects includes...\n\n * WavefieldSampler (Wavefield.hh) pointer\n * Hydrodynamics (Physics.hh) pointer\n   * Private data of Hydrodynamics object includes a WavefieldSampler pointer.  \n\n### HydrodynamicsPlugin, OnUpdate\n\nCalls UpdatePhysics(), which again retrieves the Wavefield object pointer (why do this again?).  Then loops through the vector of HydrodynamicsLinkData objects to...\n\n  * Update the each Hydrodynamics.WavefieldSampler\n  * Call Hydrodynamics.Update() method which (takes the Hydrodynamics.WavefieldSampler as an input argument?) calculates forces and torques on the link\n\t\n------------------------------------------------------\n\n\nThe above explanation is limited - I may be missing some of the implementation.", "markup": "markdown", "html": "<p>Rhys provided a very interesting solution in the <a data-is-external-link=\"true\" href=\"https://github.com/srmainwaring/asv_wave_sim\" rel=\"nofollow\">asv_wave_sim</a> project.  Going through that project, there are two significant innovations:</p>\n<ol>\n<li>The visualization and physics share a common wave field.  This is done by having a WavefieldModelPlugin associated with the Ocean model.  Two WavefieldVisualPlugins request the wave field parameters via Gazebo messages which then drives the OpenGL shader.  The HydrodynamicsPlugin associated with the physical objects within the wave field access a shared WavefieldEntity pointer which is used to access a Wavefield object directly from the WavefieldModelPlugin.</li>\n<li>The buoyancy calculation is generalized to use triangle meshes as described in Jacques Kerner's two part blog describing boat physics for games - see <a data-is-external-link=\"true\" href=\"https://github.com/srmainwaring/asv_wave_sim\" rel=\"nofollow\">asv_wave_sim</a> Acknowledgments.</li>\n</ol>\n<p>The WAM-V geometry (twin cylindrical hulls) is sufficiently simple that, as a first step, we might consider Rhys's synchronization of the visual and physical (1) without adding the complexity of mesh-based buoyancy (2).  This might also allow us to avoid licensing issues associated with using CGAL.</p>\n<p>Here is my notes from going through the code...</p>\n<hr />\n<h1 id=\"markdown-header-asv_wave_sim-explanation\">asv_wave_sim Explanation</h1>\n<h2 id=\"markdown-header-model-ocean_waves\">Model: ocean_waves</h2>\n<p>The <code>ocean_waves</code> model includes three plugins:</p>\n<ol>\n<li>WavefieldModelPlugin, inherits from ModelPlugin.  Instantiates a WavefieldEntity and a Wavefield object.  Wave field parameters are passed to the Wavefield object.  Subscribes to Gazebo message on <code>~/request</code>.  When receives message, responds on <code>~/response</code> with wave field parameters.</li>\n<li>A WavefieldVisualPlugin for the water surface, inherits from VisualPlugin.  Requests wave parameters from the WavefieldModelPlugin via Gazebo message.  Uses <code>rendering</code> API to set input parameters to OpenGL shader GernstnerWaves.frag.</li>\n<li>Another  WavefieldVisualPlugin for below the water surface.  Uses the same parameters and shader. </li>\n</ol>\n<h3 id=\"markdown-header-wavefieldmodelplugin-onupdate\">WavefieldModelPlugin, OnUpdate</h3>\n<p>The update is throttled to a nominal 30 Hz.  The WavefieldEntity is updated, which calls the Wavefield Update and UpdateGerstnerWave methods.  The Wavfield UpdateGerstnerWave method modifies the underlying CGAL Surface_mesh object based on the Gerstner wave model for the water surface.</p>\n<h2 id=\"markdown-header-model-box\">Model: box</h2>\n<p>For objects within the wave field, the HydrodynamicsPlugin, a ModelPlugin, connects the object to the wave field.  The <code>wave_model</code> plugin parameter specifies the name of the model that includes the WavefieldModelPlugin.</p>\n<h3 id=\"markdown-header-hydrodynamicsplugin-init\">HydrodynamicsPlugin, Init</h3>\n<p>Calls InitPhysics() which retrieves the specified ModelPtr by name, which then gets the a pointer to a WavefieldEntity object from within the WavefieldModelPlugin.  Finally calls the WavefieldEntity GetWaveField method to return a shared pointer to the Wavefield object.</p>\n<p>Creates a vector of HydrodynamicsLinkData objects, one for each link in the model.  Each HydrodynamicsLinkData objects includes...</p>\n<ul>\n<li>WavefieldSampler (Wavefield.hh) pointer</li>\n<li>Hydrodynamics (Physics.hh) pointer</li>\n<li>Private data of Hydrodynamics object includes a WavefieldSampler pointer.  </li>\n</ul>\n<h3 id=\"markdown-header-hydrodynamicsplugin-onupdate\">HydrodynamicsPlugin, OnUpdate</h3>\n<p>Calls UpdatePhysics(), which again retrieves the Wavefield object pointer (why do this again?).  Then loops through the vector of HydrodynamicsLinkData objects to...</p>\n<ul>\n<li>Update the each Hydrodynamics.WavefieldSampler</li>\n<li>Call Hydrodynamics.Update() method which (takes the Hydrodynamics.WavefieldSampler as an input argument?) calculates forces and torques on the link</li>\n</ul>\n<hr />\n<p>The above explanation is limited - I may be missing some of the implementation.</p>", "type": "rendered"}, "created_on": "2019-03-05T23:50:56.482717+00:00", "user": {"display_name": "Brian Bingham", "uuid": "{9cdea257-248f-486e-8858-49d8485a916f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9cdea257-248f-486e-8858-49d8485a916f%7D"}, "html": {"href": "https://bitbucket.org/%7B9cdea257-248f-486e-8858-49d8485a916f%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1/7a690884-fc47-4bca-9c2b-baecee4d3dc9/128"}}, "nickname": "brian_bingham", "type": "user", "account_id": "557058:6c52d6e5-77e0-41a8-8b6e-cb9462f4d5f1"}, "updated_on": null, "type": "issue_comment", "id": 50911053}