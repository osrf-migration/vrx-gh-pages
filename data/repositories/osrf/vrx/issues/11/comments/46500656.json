{"links": {"self": {"href": "data/repositories/osrf/vrx/issues/11/comments/46500656.json"}, "html": {"href": "#!/osrf/vrx/issues/11#comment-46500656"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/vrx/issues/11.json"}}, "type": "issue", "id": 11, "repository": {"links": {"self": {"href": "data/repositories/osrf/vrx.json"}, "html": {"href": "#!/osrf/vrx"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e278ca38-7edb-4e62-b785-46dff5617d98}ts=2274605"}}, "type": "repository", "name": "vrx", "full_name": "osrf/vrx", "uuid": "{e278ca38-7edb-4e62-b785-46dff5617d98}"}, "title": "Create holonomic configuration"}, "content": {"raw": "The plugin is passed the robot's model ([physics::ModelPtr](http://osrf-distributions.s3.amazonaws.com/gazebo/api/7.1.0/classgazebo_1_1physics_1_1Model.html))  in the Load function. It can get all the link/joint poses from this object, it just needs to know the name of the joints to look at (right now they are hardcoded in the <left_propeller_joint> and <right_propeller_joint> tags). \n\nThe more \"ROSified\" way is to use [ros_control](http://wiki.ros.org/ros_control). This package is meant to abstract away the hardware interfaces so users can write one controller and have it run seamlessly with the simulation or with the motor drivers on their real platform. I don't personally have experience with this package, but it could be cool later down the line!", "markup": "markdown", "html": "<p>The plugin is passed the robot's model (<a data-is-external-link=\"true\" href=\"http://osrf-distributions.s3.amazonaws.com/gazebo/api/7.1.0/classgazebo_1_1physics_1_1Model.html\" rel=\"nofollow\">physics::ModelPtr</a>)  in the Load function. It can get all the link/joint poses from this object, it just needs to know the name of the joints to look at (right now they are hardcoded in the &lt;left_propeller_joint&gt; and &lt;right_propeller_joint&gt; tags). </p>\n<p>The more \"ROSified\" way is to use <a data-is-external-link=\"true\" href=\"http://wiki.ros.org/ros_control\" rel=\"nofollow\">ros_control</a>. This package is meant to abstract away the hardware interfaces so users can write one controller and have it run seamlessly with the simulation or with the motor drivers on their real platform. I don't personally have experience with this package, but it could be cool later down the line!</p>", "type": "rendered"}, "created_on": "2018-06-29T17:15:07.037981+00:00", "user": {"display_name": "Kevin Allen", "uuid": "{29f672ad-72f4-434e-bb0e-c6f2f69974f2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B29f672ad-72f4-434e-bb0e-c6f2f69974f2%7D"}, "html": {"href": "https://bitbucket.org/%7B29f672ad-72f4-434e-bb0e-c6f2f69974f2%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/355d0415f6040ffb168f44275ac2ee2fd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsKA-1.png"}}, "nickname": "kev-the-dev", "type": "user", "account_id": "5b04a6cf8a69f52b3ba2e5db"}, "updated_on": null, "type": "issue_comment", "id": 46500656}